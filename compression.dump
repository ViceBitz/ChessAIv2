
/**
 * A class to handle compressing chess states into Strings and managing the data files, allowing for
 * access and retrieval
 * 
 * @author Victor Gong
 * @version 4/11/2023
 */
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.util.TreeMap;

public final class Compression
{
	private static TreeMap<CompressedBoard, CompressionInfo> allStates = new TreeMap<>();
	private static final int TABLE_SIZE_CUTOFF = 8000000; // Maximum states that table/file can hold
	private static final int STATE_DEPTH_CUTOFF = 2; //Only tracks states with depth >= than this (for quie, >= than -this)
	private static CompressionWriter compressionWriter = new CompressionWriter();
	private static final long[] ZOBRIST_KEYS = new long[773];
	private static boolean tableLocked = false; //boolean that locks the state table on true
	
	private static final boolean SAVETOFILE = false;
	
	public static void generateZobristKeys()
	{
		int index = 0;
		//64 squares from the LSB to MSB, 12 pieces with first 6 as White and next 6 as Black (64*12)
		for (int i=0;i<64;i++) {
			for (int j=0;j<12;j++) {
				ZOBRIST_KEYS[index++] = Bitboard.generateRandomMagic();
			}
		}
		//Another 4 for Castling Rights (Short White, Long White, Short Black, Long Black)
		for (int i=0;i<4;i++) {
			ZOBRIST_KEYS[index++] = Bitboard.generateRandomMagic();
		}
		//Last one for side to move = White
		ZOBRIST_KEYS[index] = Bitboard.generateRandomMagic();
	}

	/**
	 * Compresses the current board state into a base90 number stored in a String
	 * 
	 * @param board The current board
	 * @param color The color to play
	 * @return The compressed string
	 */
	public static long compressState(Board board, int colorToMove)
	{
		// Enums for pieces (White, Black)
		int[][] enumTable = {
				{0,1,2,3,4,5},
				{6,7,8,9,10,11}
		};
		
		long zobristHash = 0L;
		
		//Piece Hashing
		for (int i = 0; i < board.getNumRows(); i++)
		{
			for (int j = 0; j < board.getNumCols(); j++)
			{
				Piece p = board.get(i, j);
				long pieceHash = 0L;
				if (p != null) {
					int colorEnum = p.getColor().equals(Color.WHITE) ? 0 : 1;
					int squareEnum = Bitboard.toBBIndex(i,j);
					if (Game.NEAR_COLOR.equals(Color.BLACK)) squareEnum = 63 - squareEnum; //Always compress White near-side
					pieceHash = ZOBRIST_KEYS[squareEnum*12+enumTable[colorEnum][p.getEnum()-1]];
				}
				
				zobristHash ^= pieceHash;
			}
		}

		/**
		 * Add tag for castling rights
		 */
		int castlingRightsWhite = board.getCastlingRights(Color.WHITE);
		int castlingRightsBlack = board.getCastlingRights(Color.BLACK);

		if (castlingRightsWhite == 1) zobristHash ^= ZOBRIST_KEYS[64*12];
		else if (castlingRightsWhite == 2) zobristHash ^= ZOBRIST_KEYS[64*12+1];
		else zobristHash ^= ZOBRIST_KEYS[64*12]^ZOBRIST_KEYS[64*12+1];

		if (castlingRightsBlack == 1) zobristHash ^= ZOBRIST_KEYS[64*12+2];
		else if (castlingRightsBlack == 2) zobristHash ^= ZOBRIST_KEYS[64*12+3];
		else zobristHash ^= ZOBRIST_KEYS[64*12+2]^ZOBRIST_KEYS[64*12+3];

		/*
		 * Add tag for color to play (white)
		 */
		if (colorToMove == 1) zobristHash ^= ZOBRIST_KEYS[64*12+4];

		return zobristHash;
	}
	
	
	/**
	 * Clears the data file
	 * 
	 * @throws IOException
	 */
	public static void clearFile() throws IOException
	{
		compressionWriter.clearFile();
	}
	
	/**
	 * Loads the state table from the file
	 */
	public static void setup() throws IOException
	{
		//Read in the state table from data file
		BufferedReader br = new BufferedReader(new FileReader(CompressionWriter.DATA_FILE));
		StringTokenizer s;
		String nextLine;
		while ((nextLine = br.readLine()) != null)
		{
			s = new StringTokenizer(nextLine);
			if (allStates.size() >= TABLE_SIZE_CUTOFF)
			{
				break;
			}
			String key = s.nextToken();
			int nodeType = Integer.parseInt(s.nextToken());
			int depth = Integer.parseInt(s.nextToken());
			int value = Integer.parseInt(s.nextToken());

			allStates.put(key, new CompressionInfo(nodeType, depth, value));
		}
		br.close();
		
		//Start the CompressionWriter thread
		//compressionWriter.start();
	}
	
	/**
	 * Saves the current state table to the data file (Warning: Replaces all existing data)
	 * @throws IOException 
	 */
	public static void saveTable() throws IOException
	{
		if (!SAVETOFILE)
		{
			return;
		}
		CompressionWriter.saveToFile(allStates);
	}
	
	/**
	 * Records the move log into the log file (Appends)
	 * @throws IOException 
	 */
	public static void recordMoveLog() throws IOException
	{
		//If no moves, don't record empty log
		if (Game.moveLog.isEmpty()) {
			return;
		}
		compressionWriter.recordMoveLog(Game.moveLog);
	}
	
	/**
	 * Adds a state with a processed depth to the state table
	 * 
	 * @param key            The current state, compressed as a string
	 * @param nodeType		 The type of node
	 * @param depth			 The depth of the search
	 * @param value          The evaluation value of the state
	 */
	public static void addToTable(String key, int nodeType, int depth, int value) throws IOException
	{
		if (allStates.size() >= TABLE_SIZE_CUTOFF || tableLocked)
		{
			return;
		}
		CompressionInfo prevInfo = allStates.get(key);
		
		//Don't replace entry in TT if a shallower search (less accurate) than current TT entry (if exists)
		if (prevInfo != null && prevInfo.depth > depth) return;

		//Don't enter entry in TT if replacing a PV node (worse)
		if (prevInfo != null && prevInfo.nodeType == 1) return;

		//Don't enter entry in TT if search depth smaller than cutoff
		if ((depth > 0 && depth < STATE_DEPTH_CUTOFF)) return;
		if ((depth <= 0 && depth < -STATE_DEPTH_CUTOFF)) return;

		//Don't enter entry in TT if checkmate (unreliable)
		if (Math.abs(value) >= 99999999) return;

		allStates.put(key, new CompressionInfo(nodeType, depth, value));
		
		//compressionWriter.addToQueue(key, value);
		
	}

	/**
	 * Checks if the state table contains a specific state
	 * 
	 * @param key The current state, compressed as a string
	 * @return True if contains, false otherwise
	 */
	public static boolean tableHasState(String key)
	{
		String fullKey = key;
		return allStates.containsKey(fullKey);
	}

	/**
	 * Retrieves a CompressionInfo object from the state table given the appropriate parameters
	 * 
	 * @precondition Key exists in the state table
	 * 
	 * @param key The current state, compressed as a string
	 * @return The evaluation value
	 */
	public static CompressionInfo retrieveFromTable(String key)
	{
		String fullKey = key;
		return allStates.get(fullKey);
	}
	
	public static void lockTable()
	{
		tableLocked = true;
	}
	
	public static boolean writerIsRunning()
	{
		return compressionWriter.isWriting() && compressionWriter.isAlive();
	}
	
	public static void printDataDetails()
	{
		DecimalFormat df = new DecimalFormat("###,###,###,###.#");
		System.out.println("----- Compression Settings -----");
		System.out.println("COMPRESSION BASE: 36");
		System.out.println("CURRENT MEMORY USAGE: " + df.format(Runtime.getRuntime().totalMemory()/1024.0/1024.0) + " MB");
		System.out.println("MAX HEAP MEMORY: " + df.format(Runtime.getRuntime().maxMemory()/1024.0/1024.0) + " MB");
		System.out.println("TOTAL STATES IN TABLE: " + df.format(allStates.size()));
		System.out.println("% TABLE SPACE USED: " + df.format(allStates.size()/(double)TABLE_SIZE_CUTOFF*100) + "%");
	}
}
